/**
 * BNF grammar for Regular Expressions.
 *
 * Based on RegExp grammar from ECMAScript:
 * http://www.ecma-international.org/ecma-262/7.0/#sec-patterns
 *
 * Parser generated by Syntax tool (npm: syntax-cli)
 *
 * Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 *
 * MIT Style License.
 */

// --------------------------------------------
// 1. Lexical grammar.

%lex

CHAR                    [^*?+\[()]
ESC                     \\
U                       [0-9a-fA-F]

GROUP_NAME              ([\w$]|\\'u'[0-9a-fA-F]{4}|\\'u{'[0-9a-fA-F]{1,}'}')+

/**
 * Lexer state for character class.
 *
 * Some meta symbols inside a character class are treated as simple
 * symbols, so we return different token types for them.
 *
 * E.g. `(` yields L_PAREN token by default, however in a character
 * class it's  a simple symbol:
 *
 *   '('          return 'L_PAREN'
 *   <class>'('   return 'CHAR'
 *
 * This allows making BNF grammar simpler with less productions, and states.
 */
%s class

%%

<class>{ESC}'-'          return 'ESC_CHAR'
<class>'-'               return 'DASH'
<class>'/'               return 'CHAR'

<class>'{'               return 'CHAR'

'{'\d+'}'                return 'RANGE_EXACT'
'{'\d+',}'               return 'RANGE_OPEN'
'{'\d+','\d+'}'          return 'RANGE_CLOSED'

{ESC}'k<'{GROUP_NAME}'>' return 'NAMED_GROUP_REF'

{ESC}'b'                 return 'ESC_b'
{ESC}'B'                 return 'ESC_B'

{ESC}'c'[a-zA-Z]         return 'CTRL_CH'

{ESC}'0'\d{1,2}          return 'OCT_CODE'
{ESC}'0'                 return 'DEC_CODE'
{ESC}\d{1,3}             return 'DEC_CODE'

{ESC}'u'{U}{4}           return 'U_CODE'
{ESC}'u{'{U}{1,}'}'      return 'U_CODE'

{ESC}'x'{U}{2}           return 'HEX_CODE'

{ESC}[tnrdDsSwWvf]       return 'META_CHAR'

{ESC}'/'                 return 'ESC_CHAR'

{ESC}{CHAR}              return 'ESC_CHAR'
{ESC}[*?+\[()]           return 'ESC_CHAR'

<class>'('               return 'CHAR'
<class>')'               return 'CHAR'

'(?='                    return 'POS_LA_ASSERT'
'(?!'                    return 'NEG_LA_ASSERT'

'(?<='                   return 'POS_LB_ASSERT'
'(?<!'                   return 'NEG_LB_ASSERT'

'(?:'                    return 'NON_CAPTURE_GROUP'

'(?<'{GROUP_NAME}'>'     { yytext = yytext.slice(3, -1); return 'NAMED_CAPTURE_GROUP' }

'('                      return 'L_PAREN'
')'                      return 'R_PAREN'

<class>[*?+[^$]          return 'CHAR'
<class>{ESC}']'          return 'ESC_CHAR'

<class>']'               { this.popState(); return 'R_BRACKET' }

'^'                      return 'BOS'
'$'                      return 'EOS'

'*'                      return 'STAR'
'?'                      return 'Q_MARK'
'+'                      return 'PLUS'

'|'                      return 'BAR'

'.'                      return 'ANY'

'/'                      return 'SLASH'

{CHAR}                   return 'CHAR'

'[^'                     { this.pushState('class'); return 'NEG_CLASS' }
'['                      { this.pushState('class'); return 'L_BRACKET' }

/lex

// --------------------------------------------
// 2. Syntactic grammar.

%{

/**
 * Tracks capturing groups.
 */
let capturingGroupsCount = 0;

/**
 * Tracks named groups.
 */
let namedGroups = {};

/**
 * Parsing string.
 */
let parsingString = '';

yyparse.onParseBegin = (string) => {
  parsingString = string;
  capturingGroupsCount = 0;
  namedGroups = {};
};

/**
 * Extracts ranges from the range string.
 */
function getRange(text) {
  return text.match(/\d+/g).map(Number);
}

/**
 * Creates a character node.
 */
function Char(value, kind, loc) {
  let symbol;

  switch (kind) {
    case 'decimal': {
      const code = Number(value.slice(1));
      symbol = String.fromCodePoint(code);
      break;
    }
    case 'oct': {
      const code = parseInt(value.slice(1), 8);
      symbol = String.fromCodePoint(code);
      break;
    }
    case 'hex':
    case 'unicode': {
      const hex = value.slice(2).replace('{', '');
      const code = parseInt(hex, 16);
      if (code > 0x10ffff) {
        throw new SyntaxError(`Bad character escape sequence: ${value}`);
      }

      symbol = String.fromCodePoint(code);
      break;
    }
  }

  return Node({
    type: 'Char',
    value,
    kind,
    symbol,
  }, loc);
}

/**
 * Valid flags per current ECMAScript spec and
 * stage 3+ proposals.
 */
const validFlags = 'gimsuy';

/**
 * Checks the flags are valid, and that
 * we don't duplicate flags.
 */
function checkFlags(flags) {
  const seen = new Set();

  for (const flag of flags) {
    if (seen.has(flag) || !validFlags.includes(flag)) {
      throw new SyntaxError(`Invalid flags: ${flags}`);
    }
    seen.add(flag);
  }

  return flags.split('').sort().join('');
}

/**
 * Parses patterns like \1, \2, etc. either as a backreference
 * to a group, or a deciaml char code.
 */
function GroupRefOrDecChar(text, textLoc) {
  const reference = Number(text.slice(1));

  if (reference > 0 && reference <= capturingGroupsCount) {
    return Node({
      type: 'Backreference',
      kind: 'number',
      number: reference,
      reference,
    }, textLoc);
  }

  return Char(text, 'decimal', textLoc);
}

/**
 * Extracts from `\k<foo>` pattern either a backreference
 * to a named capturing group (if it presents), or parses it
 * as a list of char: `\k`, `<`, `f`, etc.
 */
function NamedGroupRefOrChars(text, textLoc) {
  const groupName = text.slice(3, -1);

  if (namedGroups.hasOwnProperty(groupName)) {
    return Node({
      type: 'Backreference',
      kind: 'name',
      number: namedGroups[groupName],
      reference: groupName,
    }, textLoc);
  }

  // Else `\k<foo>` should be parsed as a list of `Char`s.
  // This is really a 0.01% edge case, but we should handle it.

  let startOffset = null;

  if (textLoc) {
    startOffset = textLoc.startOffset;
  }

  const charRe = /^[\w$<>]/;
  const uRe = /^\\u[0-9a-fA-F]{4}/;
  const ucpRe = /^\\u\{[0-9a-fA-F]{1,}\}/;
  let loc;

  const chars = [
    // Init to first \k, taking 2 symbols.
    Char(
      text.slice(1, 2),
      'simple',
      startOffset
        ? {startOffset, endOffset: startOffset += 2}
        : null
    ),
  ];

  // For \k
  chars[0].escaped = true;

  // Other symbols.
  text = text.slice(2);

  while (text.length > 0) {
    let matched = null;

    // Unicode, \u003B or \u{003B}
    if ((matched = text.match(uRe)) || (matched = text.match(ucpRe))) {
      if (startOffset) {
        loc = {
          startOffset,
          endOffset: (startOffset += matched[0].length),
        };
      }
      chars.push(Char(matched[0], 'unicode', loc));
      text = text.slice(matched[0].length);
    }

    // Simple char.
    else if ((matched = text.match(charRe))) {
      if (startOffset) {
        loc = {
          startOffset,
          endOffset: ++startOffset,
        };
      }
      chars.push(Char(matched[0], 'simple', loc));
      text = text.slice(1);
    }
  }

  return chars;
}

/**
 * Creates an AST node with a location.
 */
function Node(node, loc) {
  if (yy.options.captureLocations) {
    const start = loc.startOffset;
    const end = loc.endOffset;
    node.loc = {
      source: parsingString.slice(start, end),
      start,
      end,
    };
  }
  return node;
}

/**
 * Creates location node.
 */
function loc(start, end) {
  if (!yy.options.captureLocations) {
    return null;
  }

  return {
    startOffset: start.startOffset,
    endOffset: end.endOffset,
  };
}

%}

%%

RegExp
  : SLASH Pattern SLASH OptFlags
    {
      $$ = Node({
        type: 'RegExp',
        body: $2,
        flags: checkFlags($4),
      }, loc(@1, @4 || @3))
    }
  ;

OptFlags
  : Flags
  | /* empty */ { $$ = '' }
  ;

Flags
  : CHAR
  | Flags CHAR { $$ = $1 + $2 }
  ;

Pattern
  : Disjunction
  ;

Disjunction
  : Alternative

  | Disjunction BAR Alternative
    {
      // Location for empty disjunction: /|/
      let loc = null;

      if (@2) {
        loc = {
          startOffset: @1 ? @1.startOffset : @2.startOffset,
          endOffset: @3 ? @3.endOffset : @2.endOffset,
        };
      };

      $$ = Node({
        type: 'Disjunction',
        left: $1,
        right: $3,
      }, loc)
    }
  ;

Alternative
  : AlternativeEntries
    {
      if ($1.length === 0) {
        $$ = null;
        return;
      }

      if ($1.length === 1) {
        $$ = Node($1[0], @$);
      } else {
        $$ = Node({
          type: 'Alternative',
          expressions: $1,
        }, @$)
      }
    }
  ;

AlternativeEntries
  : /* empty */
    { $$ = [] }

  | AlternativeEntries Term
    { $$ = $1.concat($2) }
  ;

Term
  : Assertion
    { $$ = Node(Object.assign({type: 'Assertion'}, $1), @$) }

  | Atom OptQuantifier
    {
      $$ = $1;

      if ($2) {
        $$ = Node({
          type: 'Repetition',
          expression: $1,
          quantifier: $2,
        }, @$)
      }
    }
  ;

Assertion
  : BOS       { $$ = { kind: '^' } }
  | EOS       { $$ = { kind: '$' } }
  | ESC_b     { $$ = { kind: '\\b' } }
  | ESC_B     { $$ = { kind: '\\B' } }

  | POS_LA_ASSERT Disjunction R_PAREN
    {
      $$ = {
        kind: 'Lookahead',
        assertion: $2,
      }
    }

  | NEG_LA_ASSERT Disjunction R_PAREN
    {
      $$ = {
        kind: 'Lookahead',
        negative: true,
        assertion: $2,
      }
    }

  | POS_LB_ASSERT Disjunction R_PAREN
    {
      $$ = {
        kind: 'Lookbehind',
        assertion: $2,
      }
    }

  | NEG_LB_ASSERT Disjunction R_PAREN
    {
      $$ = {
        kind: 'Lookbehind',
        negative: true,
        assertion: $2,
      }
    }
  ;

Atom
  : SourceCharacter
  | CharacterClass
  | Group
  ;

SourceCharacter
  : CHAR
    { $$ = Char($1, 'simple', @$) }

  | ESC_CHAR
    { $$ = Char($1.slice(1), 'simple', @$); $$.escaped = true; }

  | U_CODE
    { $$ = Char($1, 'unicode', @$) }

  | CTRL_CH
    { $$ = Char($1, 'control', @$) }

  | HEX_CODE
    { $$ = Char($1, 'hex', @$) }

  | OCT_CODE
    { $$ = Char($1, 'oct', @$) }

  | DEC_CODE
    { $$ = GroupRefOrDecChar($1, @$) }

  | META_CHAR
    { $$ = Char($1, 'meta', @$) }

  | ANY
    { $$ = Char($1, 'meta', @$) }

  | NAMED_GROUP_REF
    { $$ = NamedGroupRefOrChars($1, @1) }

  ;

OptQuantifier
  : Quantifier
  | /* empty */
  ;

Quantifier
  : QuantifierPrefix
  | QuantifierPrefix Q_MARK
    {
      $1.greedy = false;
      $$ = $1;
    }
  ;

QuantifierPrefix
  : STAR
    {
      $$ = Node({
        type: 'Quantifier',
        kind: $1,
        greedy: true,
      }, @$)
    }

  | PLUS
    {
      $$ = Node({
        type: 'Quantifier',
        kind: $1,
        greedy: true,
      }, @$)
    }

  | Q_MARK
    {
      $$ = Node({
        type: 'Quantifier',
        kind: $1,
        greedy: true,
      }, @$)
    }

  | RANGE_EXACT
    {
      const range = getRange($1);
      $$ = Node({
        type: 'Quantifier',
        kind: 'Range',
        from: range[0],
        to: range[0],
        greedy: true,
      }, @$)
    }

  | RANGE_OPEN
    {
      $$ = Node({
        type: 'Quantifier',
        kind: 'Range',
        from: getRange($1)[0],
        greedy: true,
      }, @$)
    }

  | RANGE_CLOSED
    {
      const range = getRange($1);
      $$ = Node({
        type: 'Quantifier',
        kind: 'Range',
        from: range[0],
        to: range[1],
        greedy: true,
      }, @$)
    }
  ;

Group
  : CapturingGroup
  | NonCapturingGroup
  ;

CapturingGroup
  : NAMED_CAPTURE_GROUP Disjunction R_PAREN
    {
      capturingGroupsCount++;
      namedGroups[$1] = capturingGroupsCount;

      $$ = Node({
        type: 'Group',
        capturing: true,
        name: $1,
        number: capturingGroupsCount,
        expression: $2,
      }, @$)
    }

  | L_PAREN Disjunction R_PAREN
    {
      capturingGroupsCount++;
      $$ = Node({
        type: 'Group',
        capturing: true,
        number: capturingGroupsCount,
        expression: $2,
      }, @$)
    }
  ;

NonCapturingGroup
  : NON_CAPTURE_GROUP Disjunction R_PAREN
    {
      $$ = Node({
        type: 'Group',
        capturing: false,
        expression: $2,
      }, @$)
    }
  ;

CharacterClass
  : NEG_CLASS ClassRanges R_BRACKET
    {
      $$ = Node({
        type: 'CharacterClass',
        negative: true,
        expressions: $2,
      }, @$)
    }
  | L_BRACKET ClassRanges R_BRACKET
    {
      $$ = Node({
        type: 'CharacterClass',
        expressions: $2,
      }, @$)
    }
  ;

ClassRanges
  : /* empty */
    { $$ = [] }

  | NonemptyClassRanges
  ;

NonemptyClassRanges
  : ClassAtom
    { $$ = [$1] }

  | ClassAtom NonemptyClassRangesNoDash
    { $$ = [$1].concat($2) }

  | ClassAtom DASH ClassAtom ClassRanges
    {
      $$ = [
        Node({
          type: 'ClassRange',
          from: $1,
          to: $3,
        }, loc(@1, @3))
      ];

      if ($4) {
        $$ = $$.concat($4);
      }
    }
  ;

NonemptyClassRangesNoDash
  : ClassAtom
  | ClassAtomNoDash NonemptyClassRangesNoDash
    { $$ = [$1].concat($2) }

  | ClassAtomNoDash DASH ClassAtom ClassRanges
    {
      $$ = [
        Node({
          type: 'ClassRange',
          from: $1,
          to: $3,
        }, loc(@1, @3)),
      ];

      if ($4) {
        $$ = $$.concat($4);
      }
    }
  ;

ClassAtom
  : DASH
    { $$ = Char($1, 'simple', @$) }

  | ClassAtomNoDash
  ;

ClassAtomNoDash
  : SourceCharacter

  | ESC_b
    { $$ = Char($1, 'meta', @$) }
  ;
